 
options {
  JDK_VERSION = "1.5";
  STATIC = false;
  OUTPUT_DIRECTORY = ".";
  IGNORE_CASE=true ;
}

PARSER_BEGIN(Psql)
/**
 * The parser generated by JavaCC
 */
package it.unibo.lmc.pjdbc.parser;

//import alice.tuprolog.Prolog;

//CORE
import it.unibo.lmc.pjdbc.core.Expression;
import it.unibo.lmc.pjdbc.core.expression.IOperation;
import it.unibo.lmc.pjdbc.core.expression.Operator;
import it.unibo.lmc.pjdbc.core.expression.imp.AritmeticOperation;
import it.unibo.lmc.pjdbc.core.expression.imp.CompareOperation;
import it.unibo.lmc.pjdbc.parser.commons.Limit;
import it.unibo.lmc.pjdbc.parser.commons.OrderBy;

//REQUEST
import it.unibo.lmc.pjdbc.core.request.imp.Delete;
import it.unibo.lmc.pjdbc.core.request.imp.CreateDB;
import it.unibo.lmc.pjdbc.core.request.imp.DropDB;
import it.unibo.lmc.pjdbc.core.request.imp.Drop;
import it.unibo.lmc.pjdbc.core.request.imp.Insert;
import it.unibo.lmc.pjdbc.core.request.imp.Select;
import it.unibo.lmc.pjdbc.core.request.imp.Update;
import it.unibo.lmc.pjdbc.core.request.ParsedRequest;

//SCHEMA DB
import it.unibo.lmc.pjdbc.core.schema.Table;
import it.unibo.lmc.pjdbc.core.schema.TableField;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;

public class Psql {

	private String defaultSchema;
	
}
PARSER_END(Psql)

SKIP :
{
 	" "
	| "\r"
	| "\t"
	| "\n"
}
TOKEN: /* OPERATORS */
{
	<K_AS: "AS">
	|   <K_BY:"BY">
	|   <K_DO:"DO">
	|   <K_IS:"IS">
	|   <K_IN:"IN">
	|   <K_OR:"OR">
	|   <K_ON:"ON">
	|   <K_ALL: "ALL">
	|   <K_AND: "AND">
	|   <K_ANY: "ANY">
	|   <K_KEY: "KEY">
	|   <K_NOT:"NOT">
	|   <K_SET:"SET">
	|   <K_ASC:"ASC">
	|   <K_TOP:"TOP">
	|   <K_END:"END">
	|   <K_DESC:"DESC">
	|   <K_INTO:"INTO">
	|   <K_NULL:"NULL">
	|   <K_LIKE:"LIKE">
	|   <K_DROP:"DROP">
	|   <K_JOIN:"JOIN">
	|   <K_LEFT:"LEFT">
	|   <K_FROM:"FROM">
	|   <K_OPEN:"OPEN">
	|   <K_CASE:"CASE">
	|   <K_WHEN:"WHEN">
	|   <K_THEN:"THEN">
	|   <K_ELSE:"ELSE">
	|   <K_SOME: "SOME">
	|   <K_TABLE:"TABLE">
	|   <K_DATABASE:"DATABASE">
	|   <K_WHERE:"WHERE">
	|   <K_USING:"USING">
	|   <K_UNION:"UNION">
	|   <K_GROUP:"GROUP">
	|   <K_BEGIN:"BEGIN">
	|   <K_INDEX: "INDEX">
	|   <K_INNER:"INNER">
	|   <K_LIMIT:"LIMIT">
	|   <K_OUTER:"OUTER">
	|   <K_ORDER:"ORDER">
	|   <K_DELETE:"DELETE">
	|   <K_CREATE:"CREATE">
	|   <K_SELECT:"SELECT">
	|   <K_OFFSET:"OFFSET">
	|   <K_EXISTS:"EXISTS">
	|   <K_HAVING:"HAVING">
	|   <K_INSERT:"INSERT">
	|   <K_UPDATE:"UPDATE">
	|   <K_VALUES:"VALUES">
	|   <K_ESCAPE:"ESCAPE">
	|   <K_PRIMARY:"PRIMARY">
	|   <K_NATURAL:"NATURAL">
	|   <K_REPLACE:"REPLACE">
	|   <K_BETWEEN:"BETWEEN">
	|   <K_TRUNCATE:"TRUNCATE">
	|   <K_DISTINCT:"DISTINCT">
	|   <K_INTERSECT:"INTERSECT">
}


TOKEN :
{
	< S_IDENTIFIER: ( <LETTER>|<SPECIAL_CHARS> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
	| < #LETTER: ["a"-"z","A"-"Z"]>
	| < #SPECIAL_CHARS: "$" | "_">
	| < S_BIND: ":" <S_IDENTIFIER> ("." <S_IDENTIFIER>)? >
	| < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
	| < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
	| < S_NUMBER: <FLOAT> | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )? >
	| < #FLOAT: <S_INTEGER> | <S_INTEGER> ( "." <S_INTEGER> )? | "." <S_INTEGER> >
	| < S_INTEGER: ( <DIGIT> )+ >
	| < #DIGIT: ["0"-"9"]>
}


ParsedRequest parseIt(String schema) : 
{
	this.defaultSchema = schema;
	ParsedRequest request;
}
{
	(
	    request = Select()			// SELECT column_one, column_two FROM table_name WHERE (expression) <LIMIT,ORDER BY> 
	    |
	    request = Update()			// UPDATE table_name SET (campo=valore,..) WHERE (expression) <LIMIT>;
	    |
	    request = Insert()			// INSERT INTO table_name (campi) VALUES (valori dei campi)
	    |
	    request = Delete()			// DELETE FROM table_name WHERE (expression) 
	    |
	    request = CreateDB()		// CREATE database_name
	    |
	    ( LOOKAHEAD(2)
		    request = Drop()			// DROP TABLE table_name1, table_name2,....
		    |
		    request = DropDB()			// DROP DATABASE database_name
	    )
    )
    ";"
    { return request; }
}


Update Update():
{ 
	Update update = new Update(this.defaultSchema);
	Table t;
	TableField column;
	Expression value;
	Expression where;
}
{
    <K_UPDATE> t = Table() { update.setTable(t); }
    <K_SET> column=Column() "=" value=Expression() { update.update(column.getColumnName(),value); }
	(
		"," column=Column() "=" value=Expression()  { update.update(column.getColumnName(),value); } 
	)*

   [ where=WhereClause() { update.setWhere(where); } ]
   { 
		return update;
   }
}


Insert Insert():
{ 
	Insert insert = new Insert(this.defaultSchema);
	Table t;
	TableField column;
	ArrayList<TableField> columns = new ArrayList<TableField>();
	ArrayList<Expression> values = new ArrayList<Expression>();
	Expression exp;
}
{
    <K_INSERT> [<K_INTO>] t=Table() { insert.setTable(t); }
    
    
     [LOOKAHEAD(2) "(" column=Column() { columns.add(column); } ("," column=Column() { columns.add(column); } )* ")"  ]
	
	( 
		<K_VALUES>  "(" exp=Expression() { values.add(exp); } 
					("," exp=Expression()  { values.add(exp); } )* 
					")" 
					{
				
						for (int i = 0; i < columns.size(); i++) {
							insert.insert(columns.get(i).getColumnName(),values.get(i));
						}
					
					}
		| 
		
		[LOOKAHEAD(2) "(" ]
		(
			{
			//	SubSelect itemsList;
			}
			//itemsList=SubSelect()
			{
				// DA FARE!!
			}
		)
		[ ")" ]
	)
    
    {
    	return insert; 
    }
}


Delete Delete():
{ 
	Delete delete = new Delete(this.defaultSchema);
	Table t = null;
	Expression where = null;
}
{
    <K_DELETE> [<K_FROM>] t=Table() { delete.setTable(t); }
    [where=WhereClause() { delete.setWhere(where); } ]
    { return delete; }
}

CreateDB CreateDB():
{
	CreateDB create = null;
	String t = null;
}
{
	<K_CREATE> <K_DATABASE> t=RelObjectName() { create=new CreateDB(t); }
	
	{
		return create;
	}
}

DropDB DropDB():
{
	DropDB drop = null;
	String t = null;
}
{
	
	<K_DROP> <K_TABLE> t=RelObjectName() { drop=new DropDB(t); }
	
	{
		return drop;
	}
}

Drop Drop():
{
	Drop drop = new Drop(this.defaultSchema);
	Table t = null;
}
{
	<K_DROP> <K_TABLE> t=Table() { drop.addTable(t); }
	("," t=Table() { drop.addTable(t); } )*
	
	{
		return drop;
	}
}

TableField Column():
{
	String name1 = null;
	String name2 = null;
	String name3 = null;
	
	TableField field;
	boolean distinct = false;
}
{
    // [schema.][tabella.]colonna
    [ <K_DISTINCT> {distinct = true;} ] name1=RelObjectName() [ "." name2=RelObjectName() ["." name3=RelObjectName()]]
    {
    
    	if (name3 != null) {
    		field = new TableField(name3);
    		field.setTableName(name2);
    		field.setSchema(name1);
    	} else if (name2 != null) {
    		field = new TableField(name2);
    		field.setTableName(name1);
    	} else {
    		field = new TableField(name1);
    	}
    	
    	field.setDistinct(distinct);
    	return field;
   	}
   	|
   	"*"
   	{
   		field = new TableField();
   		return field;
   	}
}

String RelObjectName()  :
{	Token tk = null; }
{
	(
	tk=<S_IDENTIFIER>
	|
	tk=<S_QUOTED_IDENTIFIER>
	| 
	tk=<S_CHAR_LITERAL>
	)
	
    { return tk.image; }
}

Table TableWithAlias():
{
	Table t = null;
	String alias = null;
}
{
	t=Table() [alias=Alias() { t.setAlias(alias); }]
	{ return t; }
}


Table Table():
{ 
	Table table = null;
	String schema = null;
	String name = null;
}
{
	(LOOKAHEAD(3) 
		schema=RelObjectName() "." name=RelObjectName()  { table = new Table(schema, name); }
		|
		name=RelObjectName() { table = new Table(this.defaultSchema,name); } 
	)	
	{		
		return table;
	}
	
}


Select Select():
{ 
	Select select = new Select(this.defaultSchema);
	TableField field;
	
	List<Table> fromList;
	List group;
	List order;
	
	Expression where;
	
	Limit limit;
}
{
	<K_SELECT> field=Column() { select.addField(field); } 
		[ "," field=Column() { select.addField(field); } ] 
	fromList=FromItemsList() { select.from(fromList); } 
		[ where=WhereClause() { select.where(where); } ] 
		[ group=GroupByColumnReferences() { select.groupBy(group); } ] 
		[ order=OrderByElements() { select.orderBy(order); } ]
		[ limit=Limit() { select.limit(limit); } ]
		
	{ return select; }	
}

String Alias():
{ String retval = null; }
{
	[<K_AS>] retval=RelObjectName()
   { return retval; }
}

List<Table> FromItemsList():
{
	ArrayList<Table> fromItemsList = new ArrayList<Table>();
	Table t = null;
}
{
    <K_FROM> t=FromItem() { fromItemsList.add(t); } 
    ( "," t=FromItem() { fromItemsList.add(t); } )* 

    { 	return fromItemsList;  }
}

Table FromItem():
{
	Table t = null;
}
{
	t=TableWithAlias()
	{
		return t;
	}
}

Expression WhereClause():
{
	Expression retval = null;
}
{
    <K_WHERE> retval=Expression()
    { return retval; }
}


ArrayList<TableField> GroupByColumnReferences():
{
	TableField columnReference = null;
	ArrayList<TableField> columnReferences = new ArrayList<TableField>();
}
{
    <K_GROUP> <K_BY> columnReference=ColumnReference() {columnReferences.add(columnReference); }
    ("," columnReference=ColumnReference()  {columnReferences.add(columnReference); } )*
	{
		return columnReferences;
	}
}


ArrayList<OrderBy> OrderByElements():
{
	ArrayList<OrderBy> orderByList = new ArrayList<OrderBy>();
	OrderBy orderByElement = null;
}
{
    <K_ORDER> <K_BY> orderByElement=OrderByElement() { orderByList.add(orderByElement); }
        ("," orderByElement=OrderByElement() { orderByList.add(orderByElement); } )*
    {
    	return orderByList; 	
    }
}

OrderBy OrderByElement():
{
	OrderBy orderByElement = new OrderBy(); 
	TableSpecificField columnReference = null;
}
{
	columnReference = ColumnReference()
    [<K_ASC> | (<K_DESC> { orderByElement.setAsc(false); } )  ]
	{
    	orderByElement.setColumnReference(columnReference);
		return orderByElement;
	}
}

Limit Limit():
{
	Limit limit = new Limit();
	Token token = null;
}
{
	(
		
		// mysql-> LIMIT offset,row_count
		<K_LIMIT> 
		 (
		 	token=<S_INTEGER> { limit.setOffset(Long.parseLong(token.image)); } 
		 ) 
		","  
		(
		token=<S_INTEGER> { limit.setRowCount(Long.parseLong(token.image)); }
		)
			
	)
	{
		return limit;
	}
}

TableField ColumnReference():
{
	TableField retval = null;
}
{
	(retval=Column())
	{
		return retval;
	}
}


Token ComparisonItem() :
{ 
	Token tk;
}
{
  (
    tk=<S_CHAR_LITERAL>
    |
    tk=<S_NUMBER>
  )

   {
      return tk;
   }
}

Expression Expression():
{
	Expression exp;
}
{
	"("
	( LOOKAHEAD(2)
		exp=AritmeticExpression()
		|
		exp=BooleanExpression()
		)
	")"
	{
		return exp;
	}
}

Expression AritmeticExpression():
{
	IOperation op;
	Token tk1;
	Token tk2;
}
{
	( 
		tk1=ComparisonItem() 
		(
		"+" { op = new Operator(AritmeticOperation.ADD); }
		|
		"-" { op = new Operator(AritmeticOperation.SUB); }
		|
		"*" { op = new Operator(AritmeticOperation.MUL); }
		|
		"/" { op = new Operator(AritmeticOperation.DIV); }
		)
		tk2=ComparisonItem()
	)
	{
		return new Expression(op,tk1,tk2);
	}
}

Expression BooleanExpression():
{
	IOperation op;
	Token tk1;
	Token tk2;
}
{
	( 
		tk1=ComparisonItem() 
			(
			"<" { op = new Operator(CompareOperation.MINOR); } 
			| 
			">" { op = new Operator(CompareOperation.MAJOR); } 
			|
			"<=" { op = new Operator(CompareOperation.MINOREQUAL); } 
			| 
			">=" { op = new Operator(CompareOperation.MAJOREQUAL); } 
			|  
			"==" { op = new Operator(CompareOperation.EQUAL); } 
		)  
		tk2=ComparisonItem()
	)
	{
		return new Expression(op,tk1,tk2);
	}
}
